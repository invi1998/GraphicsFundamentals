# 计算机图形学五：局部光照模型(Blinn-Phong 反射模型)与着色方法(Phong Shading)

## **光照模型**

到了这一部分，我们就开始进入到着色（shading）的环节了，简单来说shading就是计算出每个采样像素点的颜色是多少。本文所要介绍的是局部光照模型，并不是真正准确的模型，但是优点是计算快，效果可以接受，至今依然广泛的运用在各种游戏之中。具体会从最基础的泛光模型，Lambert漫反射模型，再到Phong反射模型，Blinn-Phong反射模型一步步推进详细详解我们如何得到一个局部光照模型。

## **1 我们为何能够看到物体？**

在进入具体模型讲解之时，我们以该章标题的问题作为一个开始，其实问题的答案我想大家都知道，**之所以物体能被我们观察，是因为人眼接收到了从物体来的光。** 没错，这其实也就是局部光照模型的基础，可以具体看看究竟有几种类型光线能从物体到人眼呢？

![img](./img/5-1.png)

如上图，可以先将光线**简单**的分为3类：

**1. 镜面反射**

**2. 漫反射**

**3. 环境光**

好，明白以上分类之后我们便进行具体模型的讲解！

(Note：本文中光强，光的亮度，光的能量皆指同一个概念，目前阶段暂不做区分，另外所有**方向向量都为单位向量**）

## **2 泛光模型**

第一个， 泛光模型即只考虑环境光，这是最简单的**经验**模型，只会去考虑环境光的影响，并且不会去精确的描述，而只是用一个简单的式子表示

![img](./img/5-2.png)

其中Ka代表物体表面对环境光的反射率，Ia代表入射环境光的亮度，Ienv存储结果，即人眼所能看到从物体表面反射的环境光的亮度。效果如下：

![img](./img/5-3.png)

没错，泛光模型只能让我们看到一个物体的平面形状，怎么能够有体积感呢，这就要添加漫反射了，即Lambert漫反射模型。

（tips：其中反射率还是光的亮度都是一个3维的RGB向量，为什么一个物体能够有颜色，其实就是它吸收了一定颜色的光，将剩下的光反射出来，也就有了颜色）

## **3 Lambert漫反射模型**

所谓Lambert漫反射模型其实就是在泛光模型的基础之上增加了漫反射项。漫反射便是光从一定角度入射之后从入射点向四面八方反射，且每个不同方向反射的光的强度相等，而产生漫反射的原因是物体表面的粗糙，导致了这种物理现象的发生。

![img](./img/5-4.png)

这种漫反射我们该去怎么模拟呢？首先应该考虑入射的角度所造成的接收到光强的损失，如下图所示：

![img](./img/5-5.png)

只有当入射光线与平面垂直的时候才能完整的接受所有光的能量，而入射角度越倾斜损失的能量越大，具体来说，我们应该将光强乘上一个cosθ=l⋅n，其中l是入射光方向，n为平面法线方向。

这个光线入射向量和反光平面的法线向量的夹角θ的余弦值，等于两个向量的点乘

好了！除了入射角度之外，光源与照射点的距离也应该考虑，直观来说，离得越远当然强度也就越弱！具体来说如图所示：

![img](./img/5-6.png)

图中中心为一个点光源，光线均匀的向周围发射，可以想象光源发射出来的能量其实是一定的，那么在任意两个圈上接受到的能量之和一定相等。而离圆心越远，圆的面积越大，单位面积所接受能量也就越弱，因此会将光强 I 除上一个 $r^2$。

OK，如此我们便可以**较为正确**的去模拟漫反射了！如下式：

![img](./img/5-7.png)

其中$k_d$为漫反射系数（也可以叫表面材质属性，不同的材质有不同的值），I入射光强，n,l分别如图中所示为法线向量和入射方向，max是为了剔除夹角大于90°的光，这里max再详细解释一下，这里max是为了剔除cos出现负数的情况，cos什么时候出现负数，那就是θ大于90°，也就是出现光线穿透这个物体，从物体里面射出来的情况，这种情况在漫反射这里是没有任何物理意义的，因为我们这里再讨论的是漫反射而不是折射，所以这里要剔除大于90°的夹角。 注意漫反射光线强度是与出射方向无关的，因此无论人眼在哪观察接收到的强度都是一样的！ 将环境光与漫反射一起考虑之后：

![img](./img/5-8.png)

因为漫反射的存在我们已经能够很明显的看出茶壶的体积感了，但依然感觉不是很真实，因为缺少了高光！即镜面反射，下一节将介绍在Lambert模型之内再加入镜面反射，从而得到Phong模型！

(tips：通过改变漫反射模型的3维反射系数kd，我们就能够得到物体表面不同的颜色）

对于反射面上一个点，为什么它会有颜色，对于shading point来说，这个点他在接受光线的时候，会吸收一部分的颜色（能量），如果不同的点他有不同的吸收率，那么我这个物体就会产生不同的颜色

对于漫反射，光线打到模型的一个点上，光线会被均匀的反射出去，就意味着，我们不管从那个视角观测它，看到的应该都是一模一样，即我们漫反射项目和我们的观测方向没有关系，从上面的公式也可以看到，我们在计算漫反射的时候，也完全没有考虑视角V

## **3 Phong反射模型**

相信所有读者都对镜面反射十分了解，这是我们从小学就知道的物理知识了！如图所示R为镜面反射方向,v为人眼观察方向。

![img](./img/5-9.png)

除了考虑漫反射中提到的光源到反射点的距离r之外，需要注意的是，观察方向在镜面反射时是很重要的，具体来说，只有当观察方向集中在反射方向周围很近的时候才能看见反射光，因此在镜面反射中会考虑 R 与 v 的夹角 α。如下式：

![img](./img/5-10.png)

对于Pong模型和Blinn-Pong模型，我们可以看到，虽然R,V 或者n,h的夹角余弦（点乘）已经可以表述他们夹角的接近与否，那这里为什么还要给他加上一个指数P呢？因为向量余弦的容忍度太高了，我们观察下面这个图，可以看到，在图1中，当我们的夹角已经有45度了，按理说这个角度下的高光已经很小了，但是在图1中可以看到，他的值还是比较大的，如果我们真的用这个夹角余弦去生成一个高光，那么我们就会看到一个超级大的高光，那这就不太合理，我们平常看到的高光它一般都是那种很小的很亮的，这就说明只要这个高光项，只要观测角离得稍微远一点，我们就应该不算它在高光里了，为了实现这个效果，这里就引入了这个指数，从下面图中可以看到，只要这个角度稍微离得大点，比如20,30°，我们就看不到高光了，这就很合理。那么这个指数一般会用到多大呢？在Blinn-Phong模型里，一般会用到100或者200

其中ks为镜面反射系数，I为入射光强，r为光源到入射点距离，注意这里在max剔除大于90°的光之后，我们还乘了一个指数p，添加该项的原因很直接，因为离反射光越远就越不应该看见反射光，需要一个指数p加速衰减

![img](./img/5-11.png)

最后我们把环境光，漫反射光，镜面反射光全部累加得到Phong模型效果：

![img](./img/5-12.png)

可以看出，此时模型其实已经非常接近真实效果了！那么Blinn-Phong反射模型是什么呢？它只是对phong模型计算反射方向与人眼观察方向角度的一个优化！

## **4 Blinn-Phong反射模型**

首先我们应该定义什么是高光，或者我们在什么情况下看得到高光？高光首先应该是这个平面或者这个物体比较光滑，这种物体他的反射都有一个特点，就是他的反射都比较接近镜面反射，那么什么时候我们能看到高光呢？就是我们的观测方向接近这个光线的镜面反射的方向的时候，我们应该能看到高光。

基于上述特点，Blinn-Phong 模型做了一个很聪明的事情，就是它观察到，当我们的视线方向和光线镜面反射方向接近的时候，其实就等同于这个光线的半程向量（就是光线的入射方向和镜面反射方向的夹角的角平分方向，根据平行四边形准则，两个单位向量相加得到的向量的方向一定沿着这两个向量的角平分线方向，即下图中的V+L，然后再给这个向量做归一化，将其变成单位向量，这就是怎么求半程向量h）和shading point的法线方向n接近

其实Phong和Blinn-Phong这两个模型的区别就是Phong模型是考虑观察方向和镜面反射方向的夹角，而Blinn-Phong模型考虑的是光线的半程向量和反射点的法线的夹角

那么如何判断两个方向是否接近呢？很简单，做点乘，两个向量越接近，他们的夹角越小，那么点乘的结果(cos)就越接近1（如果是被折射到物体里面了，那么计算结果就是小于0,这种时候就不考虑，这也就是下面的max的解释）。

如上文所提，我们将反射方向与人眼观察方向夹角替换成如下图所示的一个半程向量和法线向量的夹角

下面这个公式就是Blinn-Phong高光计算函数，ks表示的就是点的镜面反射系数，当然这里有人也会说，为什么Blinn-Phong模型不考虑光线被吸收的情况，就是这里为什么把 n .l 的点乘给去掉了？因为Blinn-Phong模型毕竟只是一个经验性模型，它把光线吸收给简化掉了，这里只考虑高光项以及我们能否看见高光

![img](./img/5-13.png)

这样的得到的结果其实是与真实计算反射与人眼观察夹角的结果是非常近似的(具体来说该角度是正确角度的一半)，但好处在于大大加速了角度计算的速度，提升了效率！

读者可以自己试试计算半程向量与反射向量谁快（加法次数，乘法次数比较）

(tips:反射向量可由入射方向在法线方向投影的两倍减去入射方向得出)

整体计算公式：

![img](./img/5-14.png)



## **5 着色方法(频率)**

在上文中我们讲解完了局部光照模型，其中主要利用了观察方向，入射光线与法线向量的位置关系，但并没有具体说究竟是三角形面的法线向量还是三角形顶点的法线向量，这也就牵扯出了本章内容——着色频率（面着色，顶点着色，像素着色），这3种不同的着色频率其实也就对应了三种不同方法。接下来一一介绍

## **5.1 Flat Shading**

**面着色**，顾名思义以每一个面作为一个着色单位。模型数据大多以很多个三角面进行存储，因此也就记录了每个面的法线向量（比如一个三角形平面，要获取平面法线，只需要计算两条边的叉积即可（叉乘）），利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，将该颜色赋予整个面，效果如下：

![img](./img/5-15.png)

Flat Shading 虽然计算很快，只需对每一个面进行一次着色计算，但是效果确是很差的，可以很明显的看到一块块面形状。因此一种改进方法就是对三角形面的每个顶点进行着色，再对三角形面内的颜色插值，即Gouraud Shading。

## **5.2 Gouraud Shading**

**顶点着色** Gouraud Shading会对每个三角形的顶点进行一次着色，那么首当其冲的问题便是，我们只有每个面的法线向量，如何得到每个顶点的法线向量呢。做法其实很简单，将所有共享这个点的面的法线向量加起来求均值，最后再标准化就得到了该顶点的法线向量了。

![image-20230113113345577](.\img\image-20230113113345577.png)

有了每个三角形的顶点向量之后，自然就可以计算出每个顶点的颜色了，那么对于三角形内部的每一个点应该怎么办呢？

![image-20230113113707391](.\img\image-20230113113707391.png)

对，就是利用我们在

[孙小磊：计算机图形学补充1：重心坐标(barycentric coordinates)详解及其作用78 赞同 · 7 评论文章![img](https://pic4.zhimg.com/v2-c76b515d06322d5076ed3fb4a9d3895f_180x120.jpg)](https://zhuanlan.zhihu.com/p/144360079)

中所提到了重心坐标来插值了！公式如下：

![img](./img/5-16.png)

其中c0,c1,c2为三角形三个顶点的颜色，α,β,γ为三角形面内一点的重心坐标，c为该点的插值之后得到的颜色。

这样就能成功的得到每一个点的颜色了，效果如下：

![img](./img/5-17.png)

可以明显看出相对于Flat Shading，Gouraud Shading的效果有着明显的提升，但这样依然还不是最好的做法，因为我们实际上只对每个三角形顶点进行了着色，然后其它的颜色都是通过插值得到，有没有一种做法可以真正的对每个点用Blinn-Phong模型计算得出颜色呢？没错，那就是Phong Shading了！

**(tips:1.这里有两个tips可以注意一下，首先重心坐标一定要是原世界坐标空间中的重心坐标，但实际计算中一般会使用投影之后的二维平面来计算重心坐标，存在着一个误差需要校正，这会在下一节笔记中展开来谈。 2. 第二点，其实按理来说Gouraud用的是双线性插值(会在之后的贝塞尔曲线中具体讲解)，但是道理都是相同的，本文这里为了方便就直接用了重心坐标插值）**

## **5.3 Phong Shading**

**逐像素着色** Phong Shading的做法其实也是很好理解的，既然要对每个点都进行光照计算，那么自然我们应该要有每个点的法线向量才可以，在第2章中，我们提到了如何得到每个顶点的法线向量，那么对于三角形内部的每一个点的法线向量自然也可以像插值颜色一般得到：

![img](./img/5-18.png)

其中n0,n1,n2分别是三角形三个顶点的法线向量，α,β,γ为三角形面内一点的重心坐标，n为该点插值之后得到的法线向量。如此便得到了任意一点的法线向量了，也当然可以对任意一点进行Blinn-Phong模型的计算了。最终对比渲染效果如下：

![img](./img/5-19.png)

可以明显看出Phong Shading对于高光的显示相比于Gouraud Shading是更真实的。有一点的要注意的是，这里所有的茶壶所使用的都是一个低精度模型，这点可以从Flat Shading的结果可以看出，面片是有限的，那么如果随着模型精度的提升，各种shading type又会有怎样的区别呢，这里给出一幅大图供读者思考

![img](./img/5-20.png)

这3中着色方案要说其具体区别，也还是需要看具体的模型来界定，我们不能始终说Flat Shading它就一定很差，比如上图中，随着模型精度越来越高，几何形体中的三角形越来越多，几何形体本身定义得就足够光滑，在这种情况下，我们就可以用一些比较简单的着色模型，得到的结果其实也是不错的。即着色频率它取决于面或者点，或者像素它们本身出现的频率，当这个模型足够复杂的时候，我们逐面或者逐顶点的着色效果就并不一定比逐像素要差，同时逐像素做也不见得着色工作就比逐面或者逐顶点的工作量大，因为当三角形面数量已经多的超出像素数的时候，这个时候Flat Shading计算量明显大于逐像素着色（例子：模型三角形数量一定，把它放得距离视角足够远，光栅化之后在屏幕上作用的像素就变得少了，三角形面在这个时候就比像素点多得多了）



## **Note：变换法线向量**

有的读者可能会疑问，法线向量不是一直存在于世界坐标空间之中吗，为什么要去变换他呢，其实原因很简单，因为**模型变换**可能会导致模型位置形状发生改变，如果属于该模型的各个三角形面的法线向量不跟着改变的话，那么此时所记录的法线向量就是错误的。因此法线向量一定也要跟着模型本身发生改变。

那么是否简单的将作用在模型本身的变换也作用在对应的法线向量之上就可以了呢？答案是否定的，这也是为什么要在这里探讨这个问题，如下图所示，一个简单矩形经过一个剪切变换M之后：

![img](./img/5-21.png)

在经过一个简单的剪切变换之后，不难发现矩形右边的法线向量没有改变，如果此时简单的用变换矩阵M⋅n得到的结果就是图中的所标注为**Mn**的向量，并不是与该面垂直的法线向量，那么对应的真正的变换矩阵应该是什么呢？ 首先定义tM=Mt是该面上任意一向量变换之后的结果, nN=Nn表示经过变换之后正确的法线向量,即真正的对法线的变换矩阵为N,目的就是求出这个N。作如下推导：



![img](./img/5-22.png)

简单来说就是加入了M−1M做了一个恒等变换，但是可以把**Mt**单独提出来为tM



![img](./img/5-23.png)

到这一步就很明显了，什么向量与变换之后的原来面上的向量垂直呢？ **法线向量!** 即上式中的$n^TM^{−1}$即为变换之后的法线向量的转置(转置是因为这里两个向量相乘的缘故)。进一步我们便可以找出N是多少

![img](./img/5-24.png)

至此应该很轻松就能看出N=(M−1)T了，推导结束！



## **总结**

至此我们知道如何计算变换之后的法线向量，又知道了如何插值出每个点的法线向量，已经可以利用上节的Blinn-Phong模型渲染出相当质量的图形了，但还有一点正如文中的tips所提到的，那就是对重心坐标插值误差的一个纠正，这究竟是个什么问题呢，我们在下一节当中进行具体探讨！

Shader Toy网站

https://www.shadertoy.com/new

VScode插件

1. Shader languages support for VS Code
2. Shader Toy

```glsl
#define PI 3.1415926
#define LV 4.
#define AA 4

vec3 Grid(in vec2 uv){
    vec3 color = vec3(0.);
    vec2 faction = 1. - 2.* abs(fract(uv) - 0.5);

    // if (abs(uv.x) <= 2. * fwidth(uv.x)){
    //     color.g = 1.;
    // } else if (abs(uv.y) <= 2. * fwidth(uv.y)){
    //     color.r = 1.;
    // } else if (faction.x < 2. * fwidth(uv.x) || faction.y < 2. * fwidth(uv.y)){
    //     color = vec3(1.);
    // }

    // 先把格子设置为白色
    color = vec3(smoothstep(LV * fwidth(uv.x), 3.9*fwidth(uv.x), faction.x));
    color += vec3(smoothstep(LV * fwidth(uv.y), 3.9*fwidth(uv.y), faction.y));

    // 填充坐标轴颜色(y， x)
    color.rb  *= smoothstep(1.9* fwidth(uv.x), 2. * fwidth(uv.x), abs(uv.x));
    color.gb  *= smoothstep(1.9* fwidth(uv.y), 2. * fwidth(uv.y), abs(uv.y));

    return color;
}

// 黑白格底色
vec3 GridBW(in vec2 uv){
    vec3 color = vec3(0.1);
    vec2 grid = floor(mod(uv, 2.));
    if (grid.x == grid.y) color = vec3(0.15);
    color = mix(color, vec3(0.), smoothstep(1.1 * fwidth(uv.x), fwidth(uv.x), abs(uv.x)));
    color = mix(color, vec3(0.), smoothstep(1.1 * fwidth(uv.y), fwidth(uv.y), abs(uv.y)));

    return color;
}


vec2 fixUV(in vec2 c){
    return LV * (2. * c - iResolution.xy) / min(iResolution.x, iResolution.y);
}

float Segment(in vec2 p, in vec2 a, in vec2 b, in float w) {
    float f = 0.;
    vec2 ba = b - a;
    vec2 pa = p - a;
    float proj = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
    float d = length(proj * ba - pa);
    // if (d <= w){
    //     f = 1.;
    // }
    f = smoothstep(w, w*0.95, d);
    return f;
}

float func(in float x){
    float T = 4. + 5. * sin(iTime);
    return cos(2. * PI / T * x);
    // return mod(x, 2.);
    // return smoothstep(0., 1., x);
}

float plotFunc(vec2 uv) {
    float f = func(uv.x);
    return smoothstep(f - 0.01, f + 0.01, uv.y);
}

float funcPlot(in vec2 uv){
    float f = 0.;
    for(float i = 0.; i <= iResolution.x; i += 1.) {
        float fx = fixUV(vec2(i, 0.)).x;
        float nextFx = fixUV(vec2(i + 1., 0.)).x;
        f += Segment(uv, vec2(fx, func(fx)), vec2(nextFx, func(nextFx)), fwidth(uv.x));
    }
    // 向量归一化
    return clamp(f, 0., 1.);
}


void mainImage(out vec4 fragColor, in vec2 fragCoord){

    vec2 uv = fixUV(fragCoord);

    vec3 color = GridBW(uv);

    // 做颜色差值
    // color += vec3(Segment(uv, vec2(4., 4.), vec2(-4., -4.), fwidth(uv.x)));
    // color = mix(color, vec3(0.3, 0.6, 0.8), funcPlot(uv));

    // 利用smoothstep画圆
    // vec3 color = vec3(0., 1., 0.5);
    // color = vec3(smoothstep(1., 0.99, length(uv)));

    float count = 0.;
    for (int m = 0; m < AA; m++) {
        for (int n = 0; n<AA; n++){
            vec2 offset = (vec2(float(m), float(n)) - 0.5 * float(AA)) / float(AA) * 2.;
            count += plotFunc(fixUV(fragCoord+offset));
        }
    }

    if (count > float(AA*AA) / 2.){
        count = float(AA * AA) - count;
    }

    count = count * 2. / float(AA*AA);
    color = mix(color, vec3(1.), count);

    // color = vec3(plotFunc(uv));

    // color = mix(color, vec3(0.5, 0.1, 0.05), plotFunc(uv));
    fragColor = vec4(color, 1);
}
```





