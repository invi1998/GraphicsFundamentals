# BITMAPINFO结构

BITMAPINFO结构具有如下形式：
```c++
typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD bmiColors[1];
} BITMAPINFO
```



BITMAPINFO结构定义了[位图](https://so.csdn.net/so/search?q=位图&spm=1001.2101.3001.7020)（DIB）的度量和颜色信息。

 

成员：

| bmiHeader | 指定了一个BITMAPINFOHEADER结构，包含了有关设备相关位图的度量和颜色格式的信息。 |
| --------- | ------------------------------------------------------------ |
| bmiColors | 指定了一个RGBQUAD或DWORD数据类型的数组，定义了位图中的颜色。 |


注释：
位图（DIB）由两个部分组成：

| (1)  | 一个BITMAPINFO结构，描述了位图的度量和颜色信息；             |
| ---- | ------------------------------------------------------------ |
| (2)  | 一个字节数组，定义了位图的像素。数组中的字节被组合在一起，但是每个扫描行必须用零填补，在一个LONG边界结束。如果高度为正的，位图的起始位置在左下角。如果高度为负，起始位置在左上角。 |
| (3)  | BITMAPINFOHEADER结构中的biBitCount成员决定了定义像素的位数以及位图中的最大颜色数。 |

**biBitCount这个成员可以是下列值之一：**

1. ·位图是单色的，bmiColors成员包含两个入口。位图数组中的每一位代表一个像素。如果该位被清除，则用bmiColors表中的第一种颜色显示该像素。如果该位被置位，则用表中的第二种颜色显示该像素。
2. ·位图最多有16种颜色，bmiColors成员中包含了最多可达16个入口。位图中的每个像素用一个4位的值来表示，该值用作颜色表的索引。例如，如果位图中的第一个字节是0x1F，这个字节代表两个像素。第一个像素包含了颜色表中第二种颜色，第二个像素包含了颜色表中第十六种颜色。
3. ·位图最多有256种颜色，bmiColors成员包含了多达256个入口。在这种情况下，数组中的每个字节代表一个像素。
4. ·位图最多有216种颜色。BITMAPINFOHEADER的biCompression成员必须是BI_BITFIELDS。bmiColors成员包含了3个DWORD型颜色掩码，分别代表了每个像素中的红，绿和蓝色成分。DWORD型掩码中的位必须是连续的，不能与其它掩码重叠。并非像素中的所有位都必须被使用。数组中的每个WORD值代表一个像素。
5. ·位图最多具有224种颜色，bmiColors成员为NULL。位图数组中的每个三字节组合分别代表像素中蓝，绿红的深度。
6. ·位图中最多具有232种颜色。BITMAPINFOHEADER中的biCompression成员必须是BI_BITFIELDS。bmiColors成员中包含了三个DWORD颜色掩码，分别指定了像素的红，绿和蓝成分。DWORD掩码中的位必须是连续的，并且不能与其它掩码重叠。并非像素中的所有位都必须被使用。数组中的每个DWORD值代表一个像素。



BITMAPINFOHEADER结构中的biClrUsed成员指定了颜色表中实际使用的索引的数目。如果biClrUsed成员被设为0，位图将使用biBitCount成员中指定的最大颜色数。

bmiColors表中的颜色应当按照其重要性的顺序出现。另一种情况是，对于使用DIB函数，bmiColors成员可以是一个16位无符号整数的数组，指定了当前实现的逻辑调色板中的索引，而不是确切的RGB值。在这种情况下，使用位图的应用程序必须调用Windows的DIB函数（CreateDIBitmap，CreateDIBPatternBrush和CreateDIBSection），iUsage参数应被设为DIB_PAL_COLORS。

如果位图是一个压缩位图（这意味着，这种位图的数组直接跟在一个指针所引用的BITMAPINFO头的后面），在使用DIB_PAL_COLORS模式的时候，biClrUsed成员必须被设为偶数，以便使DIB位图数组从DWORD边界开始。

**注意：**
如果位图被保存在文件中，或者要被传送到另一个应用程序，bmiColors成员不能包含调色板索引。除非应用程序独占地使用和控制位图，位图的颜色表中应当包含准确的RGB值。

---

# windowsDC

1、Window中，画图工具，最重要的一个东西：设备句柄。

2、Device Context--设备上下文，习惯叫设备句柄（代表一个画图工具），并且提供一套统一的接口，将硬件底层的差别隐藏起来，

3、好处：编程简单化、移植性。

4、CClientDC：客户区设备句柄。

5、CPaintDC：这个设备句柄类，只有在OnPaint函数中能被使用，如果想重载CView::OnPaint函数的话，一定要用CPaintDC这个设备句柄类。

6、HDC GetDC(HWND);获得客户区

7、HDC GetWindowDC(HWND);获得整个窗口

8、HDC BeginPaint(HWND, LPPAINTSTRUCT);只在WM_PAINT消息中使用。

9、设备句柄的属性：

　　9.1、CBrush：画刷类，决定设备句柄的背景。

　　9.2、CFont：在设备句柄代表的设备上，写字的时候，所选用的字体。

　　9.3、CPen：就当一只笔。

　　9.4、这三个要起作用，必须使用CDC::SelectObject(object)，将三个属性选入设备句柄。

　　　　如果不用了，就使用CDC::DeleteObject(object)删除。

10、其余的和画图相关的类：

　　10.1、CBitmap：代表一个图片。

　　10.2、CRgn：代表一个规则区域。

11、Windows的颜色：就是一个数据类型：COLORREF

　　COLORREF color = RGB(红(0 - 255), 绿色(0 - 255), 蓝色(0 - 255));

12、在设置DC的属性之后要还原。

```c++
HFONT hFont = CreateFontIndirect(&font);
HFONT hOldFont = (HFONT)SelectObject(hDC, hFont);
COLORREF old_color = SetTextColor(hDC, RGB(255, 0, 0));
//代码...

SetTextColor(hDC, old_color);//进行还原
SelectObject(hDC, hOldFont);//进行还原
DeleteObject(hFont);
```

---

# CreateCompatibleDC与BitBlt

**CreateCompatibleDC**

创建一个与指定设备一致的内存设备描述表。

HDC **CreateCompatibleDC**(HDC hdc //设备描述表句柄);

参数 hdc

现有的设备描述表的一个句柄，如果这个句柄为NULL，则函数创建一个和应用程序当前屏幕一致的内存设备描述表。

返回值 如果函数调用成功，则返回一个内存设备描述表句柄；否则返回NULL。

| 说明                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 创建一个与特定设备场景一致的内存设备场景                     |                                                              |
| 返回值                                                       |                                                              |
| Long，新设备场景句柄，若出错则为零                           |                                                              |
| 参数表                                                       |                                                              |
| 参数                                                         | 类型及说明                                                   |
| hdc                                                          | Long，设备场景句柄。新的设备场景将与它一致。也可能为0以创建一个与屏幕一致的设备场景 |
| 注解                                                         |                                                              |
| 在绘制之前，先要为该设备场景选定一个位图。不再需要时，该设备场景可用[DeleteDC](http://www.vbgood.com/api-manual/deletedc.htm)函数删除。删除前，其所有对象应回复初始状态 |                                                              |

BitBlt( //图形拷贝
　　HMDC0, //目标设备场景
　　x0,y0 //目标左上角坐标
　　w,h //目标图形宽、高
　　HMDC1, //源设备场景
　　x1,y1 //源左上角坐标
　　SRCCOPY //拷贝方式，这里是直接拷贝);

使用方法：

**CreateCompatibleDC**

```c++
CDC MemDC;//首先定义一个显示设备对象
CBitmap MemBitmap;//定义一个位图对象

//随后建立与屏幕显示兼容的内存显示设备
MemDC.CreateCompatibleDC(NULL);
//这时还不能绘图，因为没有地方画^_^
//下面建立一个与屏幕显示兼容的位图，至于位图的大小嘛，可以用窗口的大小
CRect rc;
GetClientRect(&rc);

MemBitmap.CreateCompatibleBitmap(pDC,rc.Width(),rc.Height());
//将位图选入到内存显示设备中
//只有选入了位图的内存显示设备才有地方绘图，画到指定的位图上
CBitmap* pOldBit=MemDC.SelectObject(&MemBitmap);

//先用背景色将位图清除干净，这里我用的是白色作为背景
//你也可以用自己应该用的颜色
MemDC.FillSolidRect(0,0,rc.Width(),rc.Height(),RGB(255,255,255));

......//一些绘制过程


//将内存中的图拷贝到屏幕上进行显示
pDC->BitBlt(0,0,rc.Width(),rc.Height(),&MemDC,0,0,SRCCOPY);

//绘图完成后的清理
MemBitmap.DeleteObject();
MemDC.DeleteDC();

// 尤其是最后两部:
MemBitmap.DeleteObject();
MemDC.DeleteDC();
// 这是清理和回收内存的!
```



---



# CreateDIBitmap与CreateDIBSection的区别

> **CreateDIBitmap**创建的是**设备相关**位图句柄 

> **CreateDIBSection**创建的是**设备无关**位图句柄

> **CreateDIBSection**创建的是一个**DIBSECTION**结构，

> **CreateDIBitmap**创建的是**BITMAP**结构。 

 

### CreateDIBSection函数原型：

```c++
HBITMAP CreateDIBSection(HDC hdc,CONST BITMAPINFO *pbmi,UINT iUsage,VOID** ppvBits,HANDLE hSection,DWORD dwOffset)；
```

当hSection为NULL时，系统会使用pbmi指定的位图信息来分配一块内存空间，该内存由操作系统管理，返回类型为HBitMAP的DIBSection对象。当以后通过调用DeleteObject函数删除该DIB时，系统将关闭指向相应内存的句柄。如果Hsection不为NULL，那么在调用DeleteObject删除该位图之后，必须自己关闭hSection内存句柄。

参数意义：

- **hdc**：设备环境句柄。如果iUsage的值是DIB_PAL_COLORS，那么函数使用该hdc的逻辑调色板对与设备无关[位图](https://baike.baidu.com/item/位图)的颜色进行初始化。（**仅在fColorUse参数设定为DIB_**
  **PAL_COLORS时，才使用hdc参数，如果fColorUse为DIB_RGB_COLORS（或0），hdc将被忽略**）**
  **
- **pbmi**：指向BITMAPINFO结构的[指针](https://baike.baidu.com/item/指针)，该结构指定了与设备无关位图的各种属性，其中包括位图的维数和颜色。
- **iUsage**：指定由pbmi参数指定的BITMAPINFO结构中的成员bmiColors[数组](https://baike.baidu.com/item/数组)包含的数据类型（要么是逻辑调色板索引值，要么是原文的RGB值）。下列值是[系统定义](https://baike.baidu.com/item/系统定义)的，其含义为：
- DIB_PAL_COLORS：表示成员bmiColors是hdc指定的设备环境的逻辑调色板，使用的是16位索引值数组。
- DIB_RGB_COLORS：表示结构BITMAPINFO中包含了RGB值的数组。
- **ppvBits**：指向一个变量的指针，该变量接收一个指向DIB位数据值的指针（其实说白了就是一个二维数组）。
- **hSection**和**dwOffset**值通常设置为NULL

 

### SetDIBits函数原型

```c++
int SetDIBits(HDC hdc, HBITMAP hbmp, UINT uStartScan, UINT cScanLines, CONST VOID *lpvBits,CONST BITMAPINFO *lpbmi, UINT fuColorUse);
```

该函数使用指定的DIB[位图](https://baike.baidu.com/item/位图)中发现的颜色数据来设置位图中的像素。

函数将lpvBits中指定的位图图像数据拷贝到hbmp对应系统给分配好的内存中。如果函数成功，那么返回值就是复制的[扫描线](https://baike.baidu.com/item/扫描线)数；如果函数失败，那么返回值是0。

参数：

- hdc：指向设备环境中的句柄。
- hbmp：指向位图的句柄。函数要使用指定DIB中的颜色数据对该[位图](https://baike.baidu.com/item/位图)进行更改。（目的地址）
- uStartScan：为参数lpvBits指向的[数组](https://baike.baidu.com/item/数组)中的、与设备无关的颜色数据指定起始[扫描线](https://baike.baidu.com/item/扫描线)。
- cScanLines：为包含与设备无关的颜色数据的数组指定扫描线数目。
- lpvBits：指向DIB颜色数据的[指针](https://baike.baidu.com/item/指针)，这些数据存储在字节类型的数组中，位图值的格式取决于参数lpbmi指向的BITMAPINFO结构中的成员biBitCount。（指定的DIB[位图](https://baike.baidu.com/item/位图)）
- lpbmi：指向BITMAPINFO数据结构的指针，该结构包含有关DIB的信息。（指定的DIB[位图](https://baike.baidu.com/item/位图)）
- fuColorUse：指定是否提供了BITMAPINFO结构中的bmiColors成员，如果提供了，那么bmiColors是否包含了明确的[RGB](https://baike.baidu.com/item/RGB/342517)值或调色板索引。参数fuColorUse必须取下列值，各值的含义为：
- DIB_PAL_COLORS：颜色表由16bit的索引值[数组](https://baike.baidu.com/item/数组)组成。这些值可以对由hdc参数标识的设备环境中的逻辑调色板进行索引。
- DIB_RGB_COLORS：提供了颜色表，并且表中包含了原义的RGB值。

 

### GetDIBits函数原型

```c++
int GetDIBits(HDC hdc, HBITMAP hbmp, UINT uStartScan, UINT cScanLines, LPVOID lpvBits, LPBITMAPINFO lpbi, UINT uUsage);
```

和SetDIBits相反，将数据从位图(hbmp)中取出来放到lpvBits指定的数组中。

---



# SelectObject

把一个对象(位图、画笔、画刷等)选入指定的设备描述表。新的对象代替同一类型的老对象。

```c++
HGDIOBJ SelectObject(
  HDC hdc,          // handle to DC
  HGDIOBJ hgdiobj   // handle to object
);
```

 

参数

1. hdc 设备描述表句柄(要载入的设备描述表句柄)
2. hgdiobj 选择要载入的对象的句柄

但该对象的句柄必须使用以下函数创建才有效：

Bitmap(位图)     CreateBitmap, CreateBitmapIndirect, 
              CreateCompatibleBitmap, CreateDIBitmap, 
              CreateDIBSection
Brush(画刷)      CreateBrushIndirect, eateDIBPatternBrush, 
              CreateDIBPatternBrushPt, CreateHatchBrush, 
              CreatePatternBrush, CreateSolidBrush 
Font(字体)       CreateFont, CreateFontIndirect


Pen(画笔)        CreatePen, CreatePenIndirect


Region(区域)       CombineRgn, CreateEllipticRgn, 
                CreateEllipticRgnIndirect, 
                CreatePolygonRgn, CreateRectRgn, 
                CreateRectRgnIndirect

返回值：如果选择对象不是区域并且函数执行成功，那么返回值是被取代的对象的句柄；如果选择对象是区域并且函数执行成功，返回如下一值；

 